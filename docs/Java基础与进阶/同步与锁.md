### volatile

volatile具有特殊的内存语义

- 保证变量的内存可见性

- 禁止volatile与普通变量重排序

  

我们定义两个变量

```Java
int a; //普通变量
volatile int b;
```

如果我们有一个线程a读这两个变量，另外一个线程b写这个变量会有以下状态

- 线程b执行以下代码

  - ```java
    a = 1; 执行这一段代码，主内存的值不会变化，a还是0
    b = 1; 执行这段代码，主内存的值发生变化，a和b的值都会更新
        为了保持内存可变性，volatile修饰的变量只要一发生更改，就会立即更新到主内存
    ```

- 线程a读取变量
  - 读取变量，a的值是1，b的值是1，因为当线程a读取b变量的时候，会立即把自己线程内的变量缓存值置成无效，然后从主内存读取最近的b值

### 线程的四种锁

- 无锁
- 偏向锁
  - 背景：在大多数情况下，锁不存在多线程竞争，而且总是由同一线程多次获得
  - 结果：偏向锁在资源无竞争的情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能
  - 原理：一个线程第一次进入同步块时，会在对象头和栈帧的锁记录着锁的偏向的线程的ID，当线程下次进入这个同步块时，会检查锁的MarkWord里面有没有自己的线程ID
    - 如果有：该线程在进入和推出同步块的时候不需要花费时间加锁和解锁
    - 如果没有：代表有另一个线程来竞争这个偏向锁
      - 竞争成功：之前的线程消失，MarkWord里面存储新的线程的ID
      - 竞争失败：之前的线程还存在，暂停之前的线程，把当前的锁升级为轻量级锁
- 轻量级锁
  - 背景：多个线程在不同时段获取同一把锁，不存在锁竞争的情况，也就没有线程阻塞，JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，Displaced Mark Word，如果一个线程获得轻量级锁，会把锁的Mark Word复制到Displaced Mark Word
  - 加锁：线程尝试用CAS将锁的Mark Word替换为指向自己线程的锁记录的指针，
    - 成功：当前线程获得锁
    - 失败：说明有其他线程竞争锁，当前线程使用自旋来获取锁，自旋：不断尝试去获得锁，如果自旋很久，还没获得锁，锁升级为重量级锁，同时线程阻塞
  - 释放锁：当前线程把Displaced Mark Word的内容复制回Mark Word，
    - CAS成功：没有发生竞争
    - CAS失败：因为其他线程自旋多次，导致锁升级，CAS操作失败，释放锁唤醒被阻塞的线程
- 重量级锁